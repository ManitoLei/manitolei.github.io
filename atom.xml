<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://manitolei.github.io</id>
    <title>ManitoLei</title>
    <updated>2021-04-14T07:37:43.833Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://manitolei.github.io"/>
    <link rel="self" href="https://manitolei.github.io/atom.xml"/>
    <subtitle>Fool&apos;s blog.</subtitle>
    <logo>https://manitolei.github.io/images/avatar.png</logo>
    <icon>https://manitolei.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, ManitoLei</rights>
    <entry>
        <title type="html"><![CDATA[佩奇]]></title>
        <id>https://manitolei.github.io/post/pei-qi/</id>
        <link href="https://manitolei.github.io/post/pei-qi/">
        </link>
        <updated>2021-04-14T06:32:59.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2021/04/14/inp1x2OPqAKMNs6.jpg" alt="xzpq.jpg" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《MySQL必知必会》-Ben Forta]]></title>
        <id>https://manitolei.github.io/post/lesslessmysql-bi-zhi-bi-hui-greatergreater-ben-forta/</id>
        <link href="https://manitolei.github.io/post/lesslessmysql-bi-zhi-bi-hui-greatergreater-ben-forta/">
        </link>
        <updated>2021-01-28T07:00:54.000Z</updated>
        <content type="html"><![CDATA[<p>SQL-Structured Query Language-结构化查询语言<br>
<img src="https://raw.githubusercontent.com/ManitoLei/Picbed_Picgo/main/20210128153155.png" alt="" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/ManitoLei/Picbed_Picgo/main/20210129162421.png" alt="" loading="lazy"><br>
show databases;<br>
//显示可用的数据库<br>
use database_name;<br>
//使用某个数据库<br>
show tables;<br>
//查看某个数据库内的表的列表<br>
show columns from table_name;<br>
describe table_name;<br>
//显示每个字段的相关信息</p>
<p>show status;<br>
//显示广泛的服务器状态信息<br>
show create database database_name;<br>
//用来显示创建特定数据库的mysql语句<br>
show create table table_name;<br>
//用来显示创建特定表的mysql语句<br>
show grants;<br>
//显示授予用户（所有用户）的安全权限<br>
show grants for 'username'@'hostname';<br>
//显示授予用户（特定用户）的安全权限<br>
show errors;<br>
//显示服务器错误消息<br>
show warnings;<br>
//显示服务器警告消息<br>
//更多的show，详见 help show</p>
<p>distinct关键字应用于所有列而不仅是前置它的列；</p>
<p>limit 要检索的行数<br>
limit 开始位置,要检索的行数<br>
//第一行为行0</p>
<p>排序-区分大小写-A与a相同吗？<br>
//取决于数据库如何设置<br>
//在字典（dictionary）排序顺序中，A被视为与a相同，这是MySQL（和大多数数据库管理系统）的默认行为</p>
<p>使用order by和limit的组合，能够找出一个列中最高或最低的值<br>
//对，but如果要找出最值相关的信息，就不行了吧。因为最值不一定只有一条数据。可以使用聚合函数</p>
<p>过滤数据-where子句<br>
SQL过滤与应用过滤：<br>
数据也可以在应用层过滤。为此目的，SQL的SELECT语句为客户机应用检索出超过实际所需的数据，然后客机代码对返回数据进行循环，以提取出需要的行。客户机代码对返回数据进行循环，以提取出需要的行。<br>
通常，这种实现并不令人满意。因此，对数据库进行了优化，以便快速有效地对数据进行过滤。让客户机应用（或开发语言）处理数据库的工作将会极大地影响应用的性能，并且使所创建的应用完全不具备可伸缩性。此外，如果在客户机上过滤数据，服务器不得不通过网络发送多余的数据，这将导致网络带宽的浪费。</p>
<p>MySQL在执行匹配时默认不区分大小写；</p>
<p>为什么要使用IN操作符？其优点具体如下。<br>
❑ 在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。<br>
❑ 在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。<br>
❑ IN操作符一般比OR操作符清单执行更快。<br>
❑ IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。<br>
IN WHERE子句中用来指定要匹配值的清单的关键字，功能与OR相当</p>
<p>用通配符进行过滤：%、_<br>
❑ 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。<br>
❑ 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。<br>
❑ 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</p>
<p>用正则表达式进行搜索：.（表示匹配任意一个字符，'.000'：比如1000、2000、…）<br>
|（or，表示或，'1000|2000'）<br>
[]（另一种形式的or语句，匹配几个字符之一，'[123] Ton'：…1 Ton…、…2 Ton…、…3 Ton…     或者'[1|2|3] Ton'这样写     [^123]：否定字符集）<br>
[]（匹配范围：[0123456789] -&gt; [1-9]，合法范围：[1-3]、[6-9]、[a-z]…）<br>
\ （所谓转义(escaping)，匹配特殊字符：.、[]、|、-、…，\.、\-、…）<br>
\f 换页  \n 换行 \r 回车 \t 制表 \v 纵向制表<br>
匹配反斜杠 \ ：\<br>
多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身。但MySQL要求两个反斜杠（MySQL自己解释一个，正则表达式库解释另一个）。<br>
<img src="https://raw.githubusercontent.com/ManitoLei/Picbed_Picgo/main/20210128151728.png" alt="" loading="lazy"><br>
匹配多个实例（*：≥0个匹配，+：≥1个匹配，?：=1 or =0个匹配，{n}：指定数目的匹配，{n,}：≥n，{n,m}：n~m，m不超过255）<br>
like '1000' 和regexp '1000'的区别：前者匹配整个列，后者出现则返回<br>
regexp匹配整个列值，实现类似上述 like '1000'：使用 ^和$定位符（anchor）即可；</p>
<p>匹配不区分大小写：可 regexp binary 区分大小写；</p>
<p>计算字段：<br>
存储在数据库表中的数据一般不是应用程序所需要的格式；<br>
计算字段是运行时在select语句内创建的；<br>
只有数据库知道select语句中哪些列是实际 的表列，哪些列是计算字段；</p>
<pre><code>concat(str1,str2,…)
//拼接字符
	//多数DBMS使用 + 或 || 来实现拼接
rtrim(column_name)
//去掉值右边的所有空格
//ltrim()、trim()
+、-、*、/
//算术计算
</code></pre>
<p>数据处理函数<br>
函数没有SQL的可移植性强；</p>
<pre><code>文本处理函数：
rtrim、upper…


日期与事件处理函数：
	
	MySQL首选日期格式：yyyy-mm-dd
	
	日期比较说明：检索出2020年9月份的所有订单：
	: date(order_date) between '2020-09-01' and '2020-09-30'
	: year(order_date) =2020 and month(order_date)=9
	
数值处理函数：
</code></pre>
<p>汇总数据<br>
聚集函数</p>
<pre><code>	avg()
	//忽略列值为null的行
	count()
	//count(*):包含null，count(column_name):忽略null
	max()、min()、sum()
	//忽略null
</code></pre>
<p>分组数据<br>
GROUP BY子句可以包含任意数目的列；<br>
GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名；<br>
如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组；</p>
<pre><code>with rollup
//每个分组汇总


having：过滤分组

select … [from …] [where…] [group by … [having …]] [order by …] [limit …] 
</code></pre>
<p>子查询：<br>
通常，子查询将返回单个列且与单个列匹配，但如果需要也可以使用多个列；<br>
：多个列使用</p>
<p>联结<br>
内联结：tablename1 inner join tablename2 on …<br>
外联结：tablename1 left/right outer join tablename2 on …</p>
<p>组合查询：union<br>
//重复的行默认被取消<br>
//union all则不会<br>
//不能多个order by</p>
<p>全文本搜索：<br>
Not all engine 支持全文本搜索；<br>
//mysql最常用的引擎：MyISAM（支持）、InnoDB（不支持）</p>
<pre><code>为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改变不断地重新索引。在对表列进行适当设计后，MySQL会自动进行所有的索引和重新索引。在索引之后，SELECT可与Match()和Against()一起使用以实际执行搜索。

一般在创建表时启用全文本搜索；（也可稍后指定）

//fulltext索引可指定单个列或者多个列
//定义之后，mysql自动维护该索引。在增加、更新或删除行时，索引随之自动更新
//在索引之后，使用两个函数 match() 和 against() 执行全文本搜索
// match()：指定被搜索的列
// against()：指定要使用的搜索表达式

//？？？我的不行啊

//啥玩意儿啊
//这章就这样吧先…
</code></pre>
<p>insert、update、delete<br>
//提高整体性能：此类操作可能很耗时，可能降低等待处理的select语句的性能：<br>
可添加关键字  low_priority  ,指示mysql降低语句的优先级<br>
insert low_priority into …</p>
<pre><code>//update：更新多行，出现一个错误，则整个操作取消，恢复原值
//使用 ignore 关键字可继续进行更新
	update ignore table_name …
	
//mysql 没有撤销（undo）按钮，谨慎使用
</code></pre>
<p>auto_increment：每个表只允许一个auto_increment列，且必须被索引<br>
//可使用 last_insert_id() 获取最后一个 auto_increment值</p>
<p>default：指定默认值，mysql只支持常量</p>
<p>Mysql 引擎类型：<br>
InnoDB：a可靠的事务处理引擎，不支持全文本搜索；<br>
MyISAM：a性能极高的引擎，支持全文本搜索，不支持事务处理；<br>
MEMORY：功能上=MyISAM，but∵数据存储在内存（not磁盘），∴速度很快（特别适合于临时表）；</p>
<pre><code>引擎类型可以混用，除了外键；
</code></pre>
<p>更新表<br>
alter table table_name add new_column_name column_type;<br>
//给表添加一个列<br>
alter table table_name drop column column_name;<br>
//删除列<br>
alter table table_name add constraint foreignkey_name foreign key (column_name') references table_name (column_name);<br>
//常见用途：定义外键<br>
//对单个表进行多个更改，可用逗号分隔<br>
//谨慎使用，记得备份</p>
<p>删除表<br>
drop table table_name;</p>
<p>重命名表<br>
rename table old_table_name to new_table_name [, … to … […]];</p>
<p>视图：虚拟的表<br>
主要用于数据检索；<br>
作用-重用，简化，保护数据；<br>
简化复杂的联结<br>
重新格式化检索出的数据<br>
过滤不想要的数据<br>
简化复杂的数据处理（简化计算字段）</p>
<p>create view view_name as SQL语句;<br>
//创建视图<br>
show create view view_name;<br>
//查看创建视图的语句<br>
drop view view_name;<br>
//删除视图<br>
create or replace view<br>
//更新视图</p>
<p>视图的数据能否更新？<br>
视情况而定。<br>
通常，可。（对其insert、update、delete，更新一个视图将更新其基表）<br>
如果不能正确的确定被更新的基数据，则不允许。<br>
（以右操作，不允许：分组、联结、子查询、并、聚集函数、distinct、导出（计算）列）</p>
<p>存储过程<br>
//MySQL 5~<br>
//为以后的使用而保存的一条或多条MySQL语句的集合<br>
简化复杂的操作，保证了数据的完整性，安全性，提高性能（使用存储过程比使用单独的sql语句要快）</p>
<p>call procedure_name([param1,[…]]);<br>
//调用存储过程<br>
create procedure procedure_name([param[s]])<br>
begin<br>
//过程体<br>
end;<br>
//创建存储过程<br>
delimiter 分隔符（一般//或;或$$，除\外 any字符都ok）<br>
//临时更改命令行实用程序的语句分隔符<br>
drop procedure procedure_name;<br>
//删除存储过程</p>
<p>参数使用：</p>
<pre><code>//这些都是小case，稍微复杂的可见本地数据库 moviesale
</code></pre>
<p>游标<br>
主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改；<br>
mysql游标只能用于存储过程；</p>
<pre><code>use steps：
	声明（定义）游标 -&gt; 打开游标 -&gt; 取数据行 -&gt; 关闭游标
	

//创建游标


//打开和关闭游标

When a cursor is opened，can use fetch语句分别访问它的每一行；
fetch：指定检索什么数据（所需的列）；  //emm，这里可以理解为指定哪一个cursor吧？
	   检索出来的数据存储在什么地方；
	   向前移动游标中的内部行指针，使下一条fetch语句检索下一行（不重复读取同一行）；



//循环检索数据
</code></pre>
<p>declare语句的次序<br>
局部变量&gt;游标&gt;句柄</p>
<p>//游标这章和全文本搜索那章一样让我迷茫，能看懂这些句子，就是还不能深刻体会。😔</p>
<p>触发器：响应delete、insert或update而自动执行的一条mysql语句；<br>
//only 表支持，视图、临时表不支持trigger<br>
//每个表每个事件每次只允许一个触发器（每个表最多支持6个触发器）<br>
//单一触发器不能与多个事件或多个表关联</p>
<p>//创建触发器：the only trigger_name，关联的表、应该响应的活动（delete、insert、update）、何时执行（处理之前or之后）</p>
<p>create trigger trigger_name after insert on table_name for each row select 'Product add!';<br>
//此触发器在insert语句成功执行后执行<br>
// for each row : 对每个插入行执行<br>
// so：对于每个插入的行显示一次 'Product add!'</p>
<p>drop trigger trigger_name;<br>
//不能更新or覆盖，只能删除触发器</p>
<p>insert触发器，可引用一个名为new的虚拟表，访问被插入的行；<br>
通常before用于数据验证；</p>
<p>delete触发器，可引用old虚拟表，访问被删除的行，只读；</p>
<p>update触发器，可引用old访问update以前的值，new访问新更新的值；</p>
<p>触发器的一种非常有意义的使用是创建审计跟踪；<br>
使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个表非常容易；</p>
<p>事务处理：用来维护数据库的完整性，保证成批的mysql操作要么完全执行，要么完全不执行；<br>
some术语<br>
○ 事务（transaction） 只一组SQL语句<br>
○ 回退（rollback） 指撤销指定SQL语句的过程<br>
○ 提交（commit） 指将为存储的SQL语句结果写入数据库表<br>
○ 保留点（savepoint） 指事务处理中设置的临时占位符（place-holder），可以对它发布回退</p>
<p>start transaction;<br>
//标识事务的开始<br>
rollback;<br>
//回退（撤销）<br>
//insert、update、delete可回退，select、create、drop不可<br>
commit;<br>
//事务提交</p>
<p>当commit或rollback语句执行后，事务会自动关闭；</p>
<p>使用保留点：部分提交或回退；</p>
<p>savepoint savepoint_name;<br>
//创建保留点（占位符）<br>
rollback to savepoint_name;<br>
//使用<br>
release savepoint;<br>
//释放保留点，在事务处理完成后会自动释放<br>
set autocommit=?;<br>
//设置事务提交行为,?=0：不自动提交更改，默认自动提交<br>
//针对每个连接，not服务器</p>
<p>字符集和校对顺序<br>
○ 字符集 字母和符号的集合<br>
○ 编码 某个字符集成员的内部表示<br>
○ 校对 为规定字符如何比较的指令</p>
<p>mysql支持众多的字符集<br>
show character set;<br>
//显示all可用的字符集以及每个字符集的描述和默认校对</p>
<p>show collation;<br>
//查看all可用的校对，以及适用的字符集</p>
<p>//有的字符集具有不止一种校对<br>
//_cs：区分大小写，_ci：不区分<br>
show variables like 'character%';<br>
show variables like 'collation%';<br>
//查看服务器所用的字符集和校对</p>
<p>//字符集很少是服务器范围（even数据库范围）的设置，不同的表，even不同的列都需要不同的字符集<br>
//可在表创建时指定：<br>
//针对表：create table … (…) default character set … collate … ;<br>
//针对列：… (… column_name column_type character set … collate … …) …<br>
//如需用与建表时不同的校对顺序排序特定的select语句：select … order by … collate …;<br>
//collate还可用于：group by、having、聚集函数、别名等<br>
//串可以使用 cast() 或 convert() 函数在字符集之间进行转换</p>
<p>数据库服务器通常包含关键的数据，确保这些数据的安全和完整需要利用访问控制；<br>
访问控制：用户对需要的数据具有适当的访问权；</p>
<p>管理用户：mysql用户账号和信息存储在名为mysql的mysql数据库中；</p>
<p>create user user_name identified by password_str;<br>
//创建用户，可使用grant创建用户账号，也可insert user表（此法不建议）<br>
rename user user_name to new_user_name;<br>
//重命名，或者update user表，rename 在mysql5及后出现<br>
drop user user_name;<br>
//删除一个用户账号（以及相关的权限。在5之前，需要使用revoke删除与账号相关的权限，then再drop user删除账号）<br>
show grants for user_name;<br>
//查看赋予用户账号的权限<br>
//新创建的用户账号没有访问权限，only 登录</p>
<p>//usage on <em>.</em> 表示根本没有权限<br>
grant 要授予的权限 on 被授予访问权限的数据库或表 to 用户名<br>
//设置访问权限</p>
<p>revoke 要授予的权限 on 被授予访问权限的数据库或表 from 用户名<br>
//撤销特定的权限</p>
<p>set password for user_name = password(new_pwd_str);<br>
//更新用户口令</p>
<p>数据库维护：<br>
备份数据</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[咸鱼刷题[Leetcode]]]></title>
        <id>https://manitolei.github.io/post/leetcode/</id>
        <link href="https://manitolei.github.io/post/leetcode/">
        </link>
        <updated>2021-01-12T14:33:25.000Z</updated>
        <content type="html"><![CDATA[<p>//终于开始学习了！( ╯▽╰)</p>
<h1 id="leetcode刷题-剑指offer数组中重复的数据">Leetcode刷题-剑指Offer（数组中重复的数据）</h1>
<blockquote>
<p>找出数组中重复的数字。</p>
</blockquote>
<blockquote>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
</blockquote>
<blockquote>
<p><strong>示例 1</strong>：</p>
</blockquote>
<blockquote>
<p><strong>输入</strong>：<br>
[2, 3, 1, 0, 2, 5, 3]<br>
<strong>输出</strong>：2 或 3</p>
</blockquote>
<blockquote>
<p><strong>限制</strong>：<br>
2 &lt;= n &lt;= 100000</p>
</blockquote>
<hr/>
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof
<p><span style="color:#777;font-weight:bold;margin-top:50px;">我提交的代码（好low啊！！！）</span></p>
<pre><code>public int findRepeatNumber(int[] nums) {
        //先给数组排序
        Arrays.sort(nums);
        //从头and尾开始找重复的数字(判断相邻数字是否存在相等的)
        for (int i = 0; i &lt; nums.length/2 ; i++) {
            if(nums[i]==nums[i+1]){
                return nums[i];
            }
            if(nums[nums.length-1-i]==nums[nums.length-1-i-1]){
                return nums[nums.length-1-i];
            }
        }
        return -1;
}
</code></pre>
<p><span style="font-size:15px;color:#888">关于Arrays.sort()，百度：在数组的数量小于47的情况下使用插入排序，在大于或等于47或少于286会进入快速排序（双轴快排），大于286采用归并排序</span></p>
<p><span style="color:#777;font-weight:bold;">Leetcode里的题解</span></p>
<pre><code>//哈希查找
public static int findRepeatNumber(int[] nums) {
        Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
        for (int i = 0; i &lt; nums.length ; i++) {
            if(set.contains(nums[i]))
                return nums[i];
            set.add(nums[i]);
        }
        return -1;
}

- 时间复杂度 O(n)
- 空间复杂度 O(n)

//数组代替哈希表
public static int findRepeatNumber(int[] nums) {
        int bucket[] = new int[nums.length];
        Arrays.fill(bucket,-1);
        for (int i = 0; i &lt; nums.length; i++) {
            if(bucket[nums[i]]!=-1)
                return nums[i];
            bucket[nums[i]]=i;
        }
        return -1;
} 
/*
	题目：在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内
*/

- 时间复杂度 O(n)
- 空间复杂度 O(n)
//哈希和数组比较：略

//最优解法
public static int findRepeatNumber4(int[] nums) {
        for (int i = 0; i &lt; nums.length ; i++) {
            while(i!=nums[i]){
                if(nums[i]==nums[nums[i]])
                    return nums[i];
                int tmp=nums[nums[i]];
                nums[nums[i]]=nums[i];
                nums[i]=tmp;
            }
        }
        return -1;
}
//woohoo，这个绝了，我这脑子想不出来就对了。

- 时间复杂度 O(n)
- 空间复杂度 O(1)
    
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://manitolei.github.io/post/hello-gridea/</id>
        <link href="https://manitolei.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>